import 'package:logging/logging.dart';
import 'package:moliseis/data/repositories/search/search_repository.dart';
import 'package:moliseis/data/services/objectbox.dart';
import 'package:moliseis/domain/models/attraction/attraction.dart';
import 'package:moliseis/domain/models/attraction/attraction_type.dart';
import 'package:moliseis/domain/models/place/place.dart';
import 'package:moliseis/domain/models/search/search_query.dart';
import 'package:moliseis/generated/objectbox.g.dart';
import 'package:moliseis/utils/extensions.dart';

class SearchRepositoryLocal implements SearchRepository {
  SearchRepositoryLocal({required ObjectBox objectBoxI})
    : _searchHistoryBox = objectBoxI.store.box<SearchQuery>(),
      _placeBox = objectBoxI.store.box<Place>(),
      _placeQuery =
          objectBoxI.store
              .box<Place>()
              .query(Place_.name.contains('', caseSensitive: false))
              .build(),
      _attractionQuery =
          objectBoxI.store
              .box<Attraction>()
              .query(Attraction_.name.contains('', caseSensitive: false))
              .build(),
      _typeQuery =
          objectBoxI.store
              .box<Attraction>()
              .query(Attraction_.dbType.oneOf(<int>[]))
              .build();

  final Box<SearchQuery> _searchHistoryBox;
  final Box<Place> _placeBox;
  final Query<Place> _placeQuery;
  final Query<Attraction> _attractionQuery;
  final Query<Attraction> _typeQuery;
  final _logger = Logger('SearchRepositoryLocal');

  @override
  Future<void> addToHistory(String query) async {
    if (query.isEmpty) {
      return;
    }

    final history = _searchHistoryBox.getAll();

    for (final element in history) {
      if (element.name.toLowerCase() == query.toLowerCase()) {
        return;
      }
    }

    _searchHistoryBox.putAsync(SearchQuery(query));
  }

  @override
  Future<List<int>> getAttractionIdsByQuery(String query) async {
    /// Searches the [Place]'s box for any [Place]s' name matching the query.
    _placeQuery.param(Place_.name).value = query;

    /// Searches the [Attraction]'s box for any [Attraction]s' name matching the
    /// query.
    _attractionQuery.param(Attraction_.name).value = query;

    /// Searches for any [AttractionType]'s name matching the search query,
    /// then creates a [List] of indexes to pass to the [ObjectBox] query.
    final matchingTypes = AttractionType.values.where(
      (type) => type.readableName.toLowerCase().contains(query.toLowerCase()),
    );

    final typeIndexes = matchingTypes.map((type) => type.index).toList();

    _typeQuery.param(Attraction_.dbType).values = typeIndexes;

    /// Generates a [Record] of [List]s of [Attraction] and [Place] types.
    /// Source: https://stackoverflow.com/a/77073846
    final (attractionQuery, placeQuery, typeQuery) = (
      _attractionQuery.findIds(),
      _placeQuery.findIds(),
      _typeQuery.findIds(),
    );

    final results = <int>[];

    results.addAll(attractionQuery);

    final test = _placeBox.getMany(placeQuery);

    for (var i = 0; i < test.length; i++) {
      final place = test[i];
      if (place != null) {
        for (final attraction in place.attractions) {
          results.add(attraction.id);
        }
      }
    }

    results.addAll(typeQuery);

    /// Purges the query results from any duplicate (generated by searching
    /// both the [Place]s' and [Attraction]s' boxes).
    final uniqueIds = <dynamic>{};
    results.retainWhere((id) => uniqueIds.add(id));

    return results;
  }

  @override
  Future<List<String>> get searchHistory async {
    final history = _searchHistoryBox.getAll();

    return List.unmodifiable(history.map<String>((element) => element.name));
  }

  @override
  Future<void> removeFromHistory(String text) async {
    try {
      final condition = SearchQuery_.name.equals(text);
      final queryBuilder = _searchHistoryBox.query(condition);
      final query = queryBuilder.build();
      final result = await query.findUniqueAsync();
      query.close();
      if (result != null) {
        _searchHistoryBox.remove(result.id);
      }
    } on Exception catch (error) {
      _logger.severe(error);
    }
  }
}
