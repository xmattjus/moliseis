import 'package:logging/logging.dart';
import 'package:moliseis/data/repositories/search/search_repository.dart';
import 'package:moliseis/data/services/objectbox.dart';
import 'package:moliseis/domain/models/attraction/attraction.dart';
import 'package:moliseis/domain/models/attraction/attraction_type.dart';
import 'package:moliseis/domain/models/place/place.dart';
import 'package:moliseis/domain/models/search/search_query.dart';
import 'package:moliseis/generated/objectbox.g.dart';
import 'package:moliseis/utils/extensions.dart';
import 'package:moliseis/utils/result.dart';

class SearchRepositoryLocal implements SearchRepository {
  SearchRepositoryLocal({required ObjectBox objectBoxI})
    : _searchHistoryBox = objectBoxI.store.box<SearchQuery>(),
      _placeBox = objectBoxI.store.box<Place>(),
      _placeQuery = objectBoxI.store
          .box<Place>()
          .query(Place_.name.contains('', caseSensitive: false))
          .build(),
      _attractionQuery = objectBoxI.store
          .box<Attraction>()
          .query(Attraction_.name.contains('', caseSensitive: false))
          .build(),
      _typeQuery = objectBoxI.store
          .box<Attraction>()
          .query(Attraction_.dbType.oneOf(<int>[]))
          .build();

  final _log = Logger('SearchRepositoryLocal');

  final Box<SearchQuery> _searchHistoryBox;
  final Box<Place> _placeBox;
  final Query<Place> _placeQuery;
  final Query<Attraction> _attractionQuery;
  final Query<Attraction> _typeQuery;

  @override
  Future<Result> addToHistory(String query) async {
    if (query.isEmpty) {
      return const Result.success(null);
    }

    try {
      final history = _searchHistoryBox.getAll();

      for (final element in history) {
        if (element.name.toLowerCase() == query.toLowerCase()) {
          return const Result.success(null);
        }
      }

      _searchHistoryBox.putAsync(SearchQuery(query));
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }

    return const Result.success(null);
  }

  @override
  Future<Result<List<int>>> getAttractionIdsByQuery(String query) async {
    try {
      /// Searches the [Place]'s box for any [Place]s' name matching the query.
      _placeQuery.param(Place_.name).value = query;

      /// Searches the [Attraction]'s box for any [Attraction]s' name matching the
      /// query.
      _attractionQuery.param(Attraction_.name).value = query;

      /// Searches for any [AttractionType]'s name matching the search query,
      /// then creates a [List] of indexes to pass to the [ObjectBox] query.
      final matchingTypes = AttractionType.values.where(
        (type) => type.label.toLowerCase().contains(query.toLowerCase()),
      );

      final typeIndexes = matchingTypes.map((type) => type.index).toList();

      _typeQuery.param(Attraction_.dbType).values = typeIndexes;

      /// Generates a [Record] of [List]s of [Attraction] and [Place] types.
      /// Source: https://stackoverflow.com/a/77073846
      final (attractionQuery, placeQuery, typeQuery) = (
        _attractionQuery.findIds(),
        _placeQuery.findIds(),
        _typeQuery.findIds(),
      );

      final results = <int>[];

      results.addAll(attractionQuery);

      final test = _placeBox.getMany(placeQuery);

      for (var i = 0; i < test.length; i++) {
        final place = test[i];
        if (place != null) {
          for (final attraction in place.attractions) {
            results.add(attraction.id);
          }
        }
      }

      results.addAll(typeQuery);

      /// Purges the query results from any duplicate (generated by searching
      /// both the [Place]s' and [Attraction]s' boxes).
      final uniqueIds = <dynamic>{};
      results.retainWhere((id) => uniqueIds.add(id));

      return Result.success(results);
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }

  @override
  Future<Result<List<String>>> get pastSearches async {
    try {
      final history = await _searchHistoryBox.getAllAsync();

      return Result.success(
        history.map<String>((element) => element.name).toList(),
      );
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }

  @override
  Future<Result> removeFromHistory(String text) async {
    try {
      final condition = SearchQuery_.name.equals(text);
      final queryBuilder = _searchHistoryBox.query(condition);
      final query = queryBuilder.build();
      final result = await query.findUniqueAsync();
      query.close();
      if (result != null) {
        _searchHistoryBox.remove(result.id);
      }
      return const Result.success(null);
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }
}
