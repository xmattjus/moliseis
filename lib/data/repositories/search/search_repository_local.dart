import 'package:logging/logging.dart';
import 'package:moliseis/data/repositories/search/search_repository.dart';
import 'package:moliseis/data/services/objectbox.dart';
import 'package:moliseis/domain/models/attraction/attraction.dart';
import 'package:moliseis/domain/models/attraction/attraction_type.dart';
import 'package:moliseis/domain/models/place/place.dart';
import 'package:moliseis/domain/models/search/search_query.dart';
import 'package:moliseis/generated/objectbox.g.dart';
import 'package:moliseis/utils/extensions.dart';
import 'package:moliseis/utils/result.dart';

class SearchRepositoryLocal implements SearchRepository {
  SearchRepositoryLocal({required ObjectBox objectBoxI})
    : _objectBox = objectBoxI,
      _searchHistoryBox = objectBoxI.store.box<SearchQuery>() {
    _init();
  }

  final _log = Logger('SearchRepositoryLocal');

  late final Query<Attraction> _attractionQuery;
  final ObjectBox _objectBox;
  late final Query<Place> _placeQuery;
  final Box<SearchQuery> _searchHistoryBox;
  late final Query<Attraction> _typeQuery;

  /// The list of the last search results.
  var _lastResults = <int>[];

  var _typeSearched = false;

  /// Caches the ObjectBox queries.
  void _init() {
    _attractionQuery = _objectBox.store
        .box<Attraction>()
        .query(Attraction_.name.contains('', caseSensitive: false))
        .build();

    _placeQuery = _objectBox.store
        .box<Place>()
        .query(Place_.name.contains('', caseSensitive: false))
        .build();

    _typeQuery = _objectBox.store
        .box<Attraction>()
        .query(Attraction_.dbType.oneOf(<int>[]))
        .build();
  }

  @override
  Future<Result> addToHistory(String query) async {
    if (query.isEmpty) {
      return const Result.success(null);
    }

    try {
      final history = _searchHistoryBox.getAll();

      for (final element in history) {
        if (element.name.toLowerCase() == query.toLowerCase()) {
          return const Result.success(null);
        }
      }

      _searchHistoryBox.putAsync(SearchQuery(query));
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }

    return const Result.success(null);
  }

  @override
  Future<Result<List<int>>> getAttractionIdsByQuery(String query) async {
    try {
      /// Searches the [Place]'s box for any [Place]s' name matching the query.
      _placeQuery.param(Place_.name).value = query;

      /// Searches the [Attraction]'s box for any [Attraction]s' name matching the
      /// query.
      _attractionQuery.param(Attraction_.name).value = query;

      /// Searches for any [AttractionType]'s name matching the search query,
      /// then creates a [List] of indexes to pass to the [ObjectBox] query.
      final matchingTypes = AttractionType.values.where(
        (type) => type.label.toLowerCase().contains(query.toLowerCase()),
      );

      final typeIndexes = matchingTypes.map((type) => type.index).toList();

      _typeQuery.param(Attraction_.dbType).values = typeIndexes;

      /// Generates a [Record] of [List]s of [Attraction] and [Place] types.
      /// Source: https://stackoverflow.com/a/77073846
      final (attractionQuery, placeQuery, typeQuery) = (
        _attractionQuery.findIds(),
        _placeQuery.findIds(),
        _typeQuery.findIds(),
      );

      final results = <int>[];

      results.addAll(attractionQuery);

      final test = _objectBox.store.box<Place>().getMany(placeQuery);

      for (var i = 0; i < test.length; i++) {
        final place = test[i];
        if (place != null) {
          for (final attraction in place.attractions) {
            results.add(attraction.id);
          }
        }
      }

      _typeSearched = typeQuery.isNotEmpty;

      results.addAll(typeQuery);

      /// Purges the query results from any duplicate (generated by searching
      /// both the [Place]s' and [Attraction]s' boxes).
      final uniqueIds = <dynamic>{};
      results.retainWhere((id) => uniqueIds.add(id));

      _lastResults = results;

      return Result.success(results);
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }

  @override
  Future<Result<List<int>>> getRelatedResults(String text) async {
    if (_typeSearched) {
      return const Result.success(<int>[]);
    }

    try {
      final attractionBox = _objectBox.store.box<Attraction>();

      final attractions = attractionBox.getMany(_lastResults);

      final attractions1 = <Attraction>[];

      for (final attraction in attractions) {
        if (attraction != null) {
          attractions1.add(attraction);
        }
      }

      final related = _getRelatedResults(attractions1);

      final results = related.map<int>((Attraction e) => e.id).toList();

      final set1 = results.toSet();
      final set2 = _lastResults.toSet();
      final diff = set1.difference(set2).toList();

      return Result.success(diff);
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }

  @override
  Future<Result<List<String>>> get pastSearches async {
    try {
      final history = await _searchHistoryBox.getAllAsync();

      return Result.success(
        history.map<String>((element) => element.name).toList(),
      );
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }

  @override
  Future<Result> removeFromHistory(String text) async {
    try {
      final condition = SearchQuery_.name.equals(text);
      final queryBuilder = _searchHistoryBox.query(condition);
      final query = queryBuilder.build();
      final result = await query.findUniqueAsync();
      query.close();
      if (result != null) {
        _searchHistoryBox.remove(result.id);
      }
      return const Result.success(null);
    } on Exception catch (error) {
      _log.severe(error);
      return Result.error(error);
    }
  }

  List<Attraction> _getRelatedResults(List<Attraction> searchResults) {
    try {
      // Creates a frequency map from direct search results where each key is
      // an AttractionType and the corresponding value represents how many
      // times that type appears in the results.
      final freqMap = searchResults.fold<Map<AttractionType, int>>({}, (
        Map<AttractionType, int> map,
        Attraction element,
      ) {
        map[element.type] = (map[element.type] ?? 0) + 1;
        return map;
      });

      // Sorts the frequency map from the most to the least appeared type.
      final sorted = freqMap.keys.toList()
        ..sort(
          (k1, k2) => (freqMap[k2]! as num).compareTo(freqMap[k1]! as num),
        );

      // Finds all the attractions having the most appeared type.
      _typeQuery.param(Attraction_.dbType).values = [sorted.first.index];

      return _typeQuery.find();
    } on Exception catch (error, stackTrace) {
      _log.severe(
        'An error occurred while searching related results',
        error,
        stackTrace,
      );

      return <Attraction>[];
    }
  }
}
